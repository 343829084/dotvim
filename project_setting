function! s:AddComponentsToPath(path)
    let l:path = fnamemodify(a:path, ':p')

    if index(b:proj_processed_components, l:path) >= 0
        return
    endif

    call add(b:proj_processed_components, l:path)

    " 把path目录下，两层子目录内的include等目录加入路径中
    for l:name in ["include"]
        for l:p in finddir(l:name, l:path . "/**2", -1)
            call s:AddPath(l:p)
        endfor
    endfor

    for l:name in ["3rd"]
        for l:p in finddir(l:name, l:path . "/**2", -1)
            call s:AddComponentsToPath(l:p)
        endfor
    endfor

    " 把path目录下，两层子目录内的boost/sscc等目录的上一层目录加入路径中
    for l:name in ["boost", "sscc"]
        for l:p in finddir(l:name, l:path . "/**2", -1)
            call s:AddPath(fnamemodify(l:p, ":h"))
        endfor
    endfor

    " 把path目录下，所有包含头文件的直接子目录include路径中
    for l:p in split(glob(l:path . "/*"), "\n")
        if findfile("*.h", l:p) || findfile("*.hpp", l:p)
            call s:AddPath(l:p)
        endif

        if isdirectory(l:p . "/lib")
            call s:AddComponentsToPath(l:p . "/lib")
        endif
    endfor
endfunction

function! s:AddPath(path)
    let l:p = fnamemodify(a:path, ":p:h")
    if isdirectory(l:p) && index(b:proj_processed_paths, l:p) < 0
        call add(b:proj_processed_paths, l:p)
        exec "setlocal path+=" . l:p
    endif
endfunction

function! SetupEnvironment()
    " 使用当前目录
    "setlocal path=.
    let b:proj_processed_components = []
    let b:proj_processed_paths = []

    let l:path = expand('%:p:h')

    " 找出到workspace下一层的目录。如/home/user/workspace/proj/dir1/dir2 =>
    " /home/usr/workspace/proj
    let l:curr = l:path
    let l:parent = fnamemodify(l:curr, ':h')

    let l:workspace_dir = $HOME
    let l:stop_dir = ''
    while l:parent != l:curr
        if index(['workspace', 'program'], fnamemodify(l:parent, ':t')) >= 0
            " l:parent目录符合要求的目录名
            let l:workspace_dir = l:parent
            let l:stop_dir = l:curr
            break
        endif

        let l:curr = l:parent
        let l:parent = fnamemodify(l:curr, ':h')
    endwhile

    let l:search_path = l:path . '/*;' . l:stop_dir

    " 加入路径上所有lib/3rd/util/framework目录下的库
    for l:d in ["lib", "3rd", "framework"]
        for l:p in finddir(l:d, l:search_path, -1)
            call s:AddComponentsToPath(l:p)
        endfor
    endfor

    " 加入路径上所有有include子目录的目录
    for l:p in finddir('include', l:search_path, -1)
        call s:AddPath(l:p)
    endfor

    " Boost库
    if match(&path, "boost") < 0    " 路径中没有boost库才需要加入
        if isdirectory($BOOST_ROOT)
            call s:AddPath($BOOST_ROOT)
        else
            let l:boost_dirs = sort(split(glob(l:workspace_dir . "/boost_*/"), "\n"))
            if len(l:boost_dirs) > 0
                call s:AddPath(l:boost_dirs[0])
            endif
        endif
    endif

    " 加入路径上所有Jamroot/Jamfile所在目录，这种目录通常都在include路径中
    for l:name in ["Jamfile", "Jamfile.v2", "Jamroot", "Jamroot.v2"]
        for l:p in findfile(l:name, l:search_path, -1)
            call s:AddPath(fnamemodify(l:p, ":p:h"))
        endfor
    endfor

    " 如果在Boost目录，则加上boost目录的上一层目录
    let l:boost_include = finddir("boost", l:search_path)
    if len(l:boost_include) > 0
        " 当前在Boost库的目录下
        call s:AddPath(fnamemodify(l:boost_include, ":p:h:h"))
    endif

    " 加入路径上所有include目录
    for l:p in finddir("include", l:search_path, -1)
        call s:AddPath(l:p)
    endfor

    call s:AddPath("/usr/include")

    " C++标准库
    let l:cpp_include_path = substitute(substitute(glob("/usr/include/c++/*/"), "^.*\n", "", ""), "/$", "", "")
    if isdirectory(l:cpp_include_path)
        call s:AddPath(l:cpp_include_path)
    endif
endfunction

augroup vim_project_setting
    autocmd BufReadPre,BufNewFile *.h,*.hpp,*.cpp,*.c,*.ipp call SetupEnvironment()
augroup end
" vim: filetype=vim fileencoding=utf-8
