function! s:AddComponentsToPath(path)
    if index(b:proj_processed_components, a:path) >= 0
        return
    endif

    call add(b:proj_processed_components, a:path)

    " 把path目录下，两层子目录内的include等目录加入路径中
    for l:name in ["include"]
        for l:p in finddir(l:name, a:path . "/**2", -1)
            call s:AddPath(l:p)
        endfor
    endfor

    for l:name in ["3rd"]
        for l:p in finddir(l:name, a:path . "/**2", -1)
            call s:AddComponentsToPath(l:p)
        endfor
    endfor

    " 把path目录下，两层子目录内的boost/sscc等目录的上一层目录加入路径中
    for l:name in ["boost", "sscc"]
        for l:p in finddir(l:name, a:path . "/**2", -1)
            call s:AddPath(fnamemodify(l:p, ":h"))
        endfor
    endfor

    " 把path目录下，所有包含头文件的直接子目录include路径中
    for l:p in split(glob(a:path . "/*"), "\n")
        if findfile("*.h", l:p) || findfile("*.hpp", l:p)
            call s:AddPath(l:p)
        endif

        if isdirectory(l:p . "/lib")
            call s:AddComponentsToPath(l:p . "/lib")
        endif
    endfor
endfunction

function! s:AddPath(path)
    let l:p = fnamemodify(a:path, ":p:h")
    if isdirectory(l:p) && index(b:proj_processed_paths, l:p) < 0
        call add(b:proj_processed_paths, l:p)
        exec "setlocal path+=" . l:p
    endif
endfunction

function! SetupEnvironment()
    " 使用当前目录
    "setlocal path=.
    let b:proj_processed_components = []
    let b:proj_processed_paths = []

    let l:path = expand('%:p')

    let l:workspace_dir = finddir("workspace", '.;')
    if ! isdirectory(l:workspace_dir)
        if isdirectory(expand('$HOME/workspace'))
            let l:workspace_dir = expand('$HOME/workspace')
        elseif isdirectory(expand('$HOME/program'))
            let l:workspace_dir = expand('$HOME/program')
        else
            let l:workspace_dir = expand('$HOME')
        endif
    endif

    " 加入路径上所有lib/3rd/util/framework目录下的库
    for l:d in ["lib", "3rd", "framework"]
        for l:p in finddir(l:d, '.;' . l:workspace_dir, -1)
            call s:AddComponentsToPath(l:p)
        endfor
    endfor

    " 加入路径上所有有include子目录的目录
    for l:p in finddir('include', '*;' . l:workspace_dir, -1)
        call s:AddPath(l:p)
    endfor

    " Boost库
    if match(&path, "boost") < 0    " 路径中没有boost库才需要加入
        if isdirectory($BOOST_ROOT)
            call s:AddPath($BOOST_ROOT)
        else
            let l:boost_dirs = sort(split(glob(l:workspace_dir . "/boost_*/"), "\n"))
            if len(l:boost_dirs) > 0
                call s:AddPath(l:boost_dirs[0])
            endif
        endif
    endif

    " 加入路径上所有Jamroot/Jamfile所在目录，这种目录通常都在include路径中
    for l:name in ["Jamfile", "Jamfile.v2", "Jamroot", "Jamroot.v2"]
        for l:p in findfile(l:name, '.;' . l:workspace_dir, -1)
            call s:AddPath(fnamemodify(l:p, ":p:h"))
        endfor
    endfor

    " 如果在Boost目录，则加上boost目录的上一层目录
    let l:boost_include = finddir("boost", '.;' . expand("$HOME"))
    if len(l:boost_include) > 0
        " 当前在Boost库的目录下
        call s:AddPath(fnamemodify(l:boost_include, ":p:h:h"))
    endif

    " 加入路径上所有include目录
    for l:p in finddir("include", '.;' . expand("$HOME"), -1)
        call s:AddPath(l:p)
    endfor

    call s:AddPath("/usr/include")

    " C++标准库
    let l:cpp_include_path = substitute(substitute(glob("/usr/include/c++/*/"), "^.*\n", "", ""), "/$", "", "")
    if isdirectory(l:cpp_include_path)
        call s:AddPath(l:cpp_include_path)
    endif
endfunction

augroup vim_project_setting
    autocmd BufReadPre,BufNewFile *.h,*.hpp,*.cpp,*.c,*.ipp call SetupEnvironment()
augroup end
" vim: filetype=vim fileencoding=utf-8
